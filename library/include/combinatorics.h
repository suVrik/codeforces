#pragma once

#include "includes.h"

// Биномиальные коэффициенты.
// http://e-maxx.ru/algo/binomial_coeff

// Сочетания: C(n, k) = n! / (k! * (n - k)!)
// Пример: C(4, 2) = 6
// Наборы: (1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)
// Пояснение: нету (1, 1), (2, 2), (3, 3), (4, 4) потому что каждый элемент в
//            сочетании должен быть уникален (в отличие от сочетаний с повторениями).
//            нету (2, 1), (3, 1), (3, 2), (4, 1), (4, 2), (4, 3) потому что
//            если поменять местами элементы, они повторяют другие наборы.

// Сочетания с повторениями: C((n), k) = C(n + k - 1, n - 1) = (n + k - 1)! / (k! * (n - 1)!)
// Пример: C((4), 2) = C(4 + 2 - 1, 4 - 1) = C(5, 3) = 10
// Наборы: (1, 1), (1, 2), (1, 3), (1, 4), (2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (4, 4)
// Пояснение: нету (2, 1), (3, 1), (3, 2), (4, 1), (4, 2), (4, 3) потому что
//            если поменять местами элементы, они повторяют другие наборы.

// Сочетания БЕЗ повторений.

ll c(ll n, ll k) {
    ll result = 1;
    for (ll i = 1; i <= k; i++) {
        result = result * (n - k + i) / i;
    }
    return result;
}

// Треугольник паскаля для сочетаний БЕЗ повторений.

vector<vector<ll>> build_pascal_triangle(size_t n) {
    vector<vector<ll>> result(n + 1, vector<ll>(n + 1));
    for (size_t i = 0; i <= n; i++) {
        result[i][0] = result[i][i] = 1;
        for (size_t k = 1; k < i; k++) {
            result[i][k] = result[i - 1][k - 1] + result[i - 1][k];
        }
    }
    return result;
}

// Перестановки: P(n) = n!
// Сколькими уникальными способами можно переставить набор из n элементов.
// Пример: P(3) = 6
// Наборы: (1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1).

// Перестановки без повторений: n! / (a! * b! * ... * z!)
// n = a + b + ... + z
// Сколькими уникальными способами можно переставить набор из a элементов одного типа,
// b элементов другого типа и т.д. Причём элементы одного типа считаются за эквивалентные.
// Наборы: (1, 1, 2, 2), (1, 2, 1, 2), (1, 2, 2, 1), (2, 1, 1, 2), (2, 1, 2, 1), (2, 2, 1, 1)

// Вычисление факториала (что эквивалентно перестановкам).

ll fac(ll n) {
    ll result = 1;
    while (n > 0) {
        result *= n--;
    }
    return result;
}

// Размещения: A(n, k) = n! / (n - k)!
// n - количество различных элементов.
// k - длина каждого набора элементов.
// Пример: A(3, 2) = 6
// Наборы: (1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)
// Отличие от сочетаний в присутствии и (1, 3) и (3, 1) и т.д.

// Размещения с повторениями: A(n, -k) = n^k
// n - количество различных элементов.
// k - длина каждого набора элементов.
// Пример: A(2, 3) = 8
// Наборы: (0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1)
// Отличие от сочетаний с повторениями в присутствии и (0, 0, 1) и (0, 1, 0) и (1, 0, 0) и т.д.
